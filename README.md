# CIS7 Course Project 
# Professor Nguyen
# Vigenère Cipher C++ Implementation
Published on May 26, 2023 by Noel Perez

https://github.com/Computer-PsiPhi/CIS7.CourseProject.Prof-Nguyen
#### *Things to consider before using this program*

This program only accepts uppercase messages without spaces or symbols. 
This program also only accepts uppercase key-words without spaces or symbols. For the program to yield the correct results, only messages and keywords in uppercases may be used. For example, *HELLOMYNAMEIS* is valid, but it could **NOT** be entered as *HELLO MY NAME IS*. Another example which would not work is *HELLO!MYNAMEIS?*. For correct results keep input limited to alphabetical characters in uppercase without symbols nor spaces between the words of your message and key-words. The program has a menu which allows the user to encrypt and decrypt messages cyclically and a sentinel value to escape at any time.


This program uses the Vigenère cipher, which is a polyalphabetic encryption algorithm to encrypt and decrypt messages. It uses modular arithmetic on the *ascii* values of each letter in a plaintext and a key to encrypt and decrypt messages. In order to encrypt a message this program uses a string to hold the plaintext message, as well as a string to hold the key-word. In the Vigenère function, a new key is generated by cyclically repeating the user's keyword until it is as long as the message they entered. Then to create the ciphertext the first letter of the message's *ascii* value is added to the first letter of the key's *ascii* value and mod 26 is performed on that value. Next 65 (or 'A' since char characters are integer values in c++) is added to bring it into the range of the capital letters. This process is repeated for the length of the message, at each and every index of the message. At the end of this process the Vigenère function returns the encrypted ciphertext back to the main function, where it is called.  For decrypting, the program subtracts the ciphertext's indices *ascii* values from the key's indices *ascii* values and adds 26 (26 because we only use 26 characters in this implementation ). Then, modulus 26 is performed on that, and added to 65 to bring it into the range of the capital letters. This process is done on each letter of the ciphertext, at every index, to yield back the original plaintext. 

--------

* The [Vigenère Cipher](https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher) is a slightly more complex version of the [Caesar Cipher](https://en.wikipedia.org/wiki/Caesar_cipher), where instead of rotating plaintext by a single letter, Vigenère allows rotation of a key-word. 

* The Vigenère Cipher is a method of encrypting alphabetic text. It uses a simple form of polyalphabetic substitution. A polyalphabetic cipher is any cipher based on substitution, using multiple substitution letters. The encryption of the original text is done using the Vigenère square or Vigenère table.
The table consists of the letters written out 26 times in different rows, each letter is shifted cyclically to the left compared to the previous letter, corresponding to the 26 possible Caesar Ciphers.
At different points in the encryption process, the cipher uses a different letter from one of the rows.
The letter used at each point depends on a repeating keyword.

## Encryption and decryption using the Vigenère algorithm

### 
- #### `input` - Uppercase alphabetical plaintext message user wants to encrypt. This program only accepts uppercase messages, without spaces nor symbols. Only the characters A-Z may be used. 
- #### `keyword` - Mandatory uppercase string used for calculating the key used by the algorithm. The keyword is needed to perform both the encryption and decryption.
- #### `output` - Uppercase ciphertext that the implementation of the  Vigenère algorithm produces. The ciphertext in this program will also only be made up of uppercase alphabetical characters. No spaces or symbols allowed.

---

## How does it work ?
### Encryption and Decryption
#### To encrypt a character the position of the index is evaluated based on the current word character and the current key character:
![Vigenere](https://pages.mtu.edu/~shene/NSF-4/Tutorial/VIG/FIG-VIG-Table-EX-M.jpg)
#### In the example above you can see that we treat both the message and the keyword string indices as a position of a character. In this case, the index of `M`, and its ascii value of 77 and index of `H` and its ascii value of 72 are added together. This produces a total of 149. To compute the correct encryption result we perform the following modular arithmetic:  (77+72)mod26 which is the same as 149mod26. The result of this operation is 19. Now we add the ascii value of 'A' which is 65 to bring it into the range of the capital letter ascii values. So 19+65=84. And 84 is the ascii value for capital T. Thus the character at that index has been encrypted. For a message or plaintext, this process is repeated for each and every letter of the plaintext message until the end is reached and every character has been encrypted, resulting in a ciphertext. The key used is generated from a key-word that repeats itself cyclically to an equal length of the original plaintext message. 
#### To decrypt, this process is reversed and the letters of the ciphertext's ascii value indices are subtracted from the key's ascii value letters indices and 26 is added because we are only encrypting 26 possible characters in our implementation. To get back to 'M' in the example above, first the ascii value of 'T' is subtracted from the ascii value of 'H' and 26 is added; then modular arithmetic is performed on the result, which looks like: (84-72+26)mod26 + 65. 65 is added to the result of the modular arithmetic to bring the result into the range of the capital letter ascii values. Thus you get back to 'M' in the example above.


## Examples
####  Vigenère cipher encrypting:

Plaintext 

```
HELLO 
```

Key Word

```
BLUE
```

Results in

```
IPFPP
```

More complex message: 

Plaintext

```
HELLOMYNAMEISNOEL
```


Key Word

```
RED
```

Results in

```
YIOCSPPRDDILJRRVP
``` 


### Vigenère cipher decrypting :

Ciphertext

```
IPFPP
```

Key Word used

```
BLUE
```

Results in

```
HELLO
```

> Explanation: \
If the user inputs the plaintext message : HELLOMYNAMEISNOEL \
And the keyword :  RED \
The output ciphertext is :   YIOCSPPRDDILJRRVP \
For generating a new key to be used in the program, the given keyword is repeated in a circular manner until it matches the length of the plain text.
The keyword "RED" generates the key "REDREDREDREDREDRE".
The plain text is then encrypted using the process explained below.
 
#### Encryption
The first letter of the plaintext, H is paired with R, the first letter of the key. So use row R and column H of the Vigenère square, which yields Y. Similarly, for the second letter of the plaintext, the second letter of the key is used, the letter at row E and column E is I. The rest of the plaintext is enciphered in a similar fashion.
Encryption:
The the plaintext(P) and key(K) are added then modulo 26 is performed. After that calculation 65 is added to bring it into the range of the capital letter *ascii* values.\
Ei = (Pi + Ki) mod 26 + 65

#### Decryption
Decryption is performed by going to the row in the table corresponding to the key, finding the position of the ciphertext letter in this row, and then using the column’s label as the plaintext. For example, in row R (from RED), the ciphertext Y appears in column H, which is the first plaintext letter. Next we go to row E (from RED), locate the ciphertext I which is found in column E, thus E is the second plaintext letter.

Di = (Ei - Ki + 26) mod 26 + 65 \
*Note: Di denotes the offset of the i-th character of the plaintext. Like offset of A is 0 and of B is 1 and so on.*
